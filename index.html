<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">

<!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Retrospectives on drug discovery">
  <meta property="og:description" content="LLMs looking back at historical 'In the Pipeline' articles">
  <meta property="og:url" content="https://jshilts.github.io/out-the-pipeline/">
  <meta property="og:image" content="https://jshilts.github.io/out-the-pipeline/assets/previewpic.png">
  <meta property="og:image:alt" content="Drug pipeline history">

  <!-- Twitter -->
  <!--<meta name="twitter:card" content="summary_large_image"> -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Retrospectives on drug discovery">
  <meta name="twitter:description" content="LLMs looking back at historical 'In the Pipeline' articles">
  <!--<meta name="twitter:image" content="https://jshilts.github.io/out-the-pipeline/assets/previewpic.png">-->
  <meta name="twitter:image" content="https://jshilts.github.io/out-the-pipeline/assets/previewpic_square.png">


<title>Retrospectives on drug discovery</title>
<style>
  /* Layout */
  body { margin:0; font-family: system-ui, Arial, sans-serif; display:flex; height:100vh; }
  nav { width: clamp(220px, 28vw, 360px); max-width:100%; border-right:1px solid #ddd; padding:12px; box-sizing:border-box; background:#fff; overflow:auto; }
  main { flex:1; min-width:0; overflow:auto; padding:20px; box-sizing:border-box; }

  /* Controls */
  .controls { display:flex; gap:12px; margin-bottom:12px; align-items:flex-start; }

  /* Year wheel */
  .year-wheel { display:flex; flex-direction:column; align-items:center; gap:6px; width:110px; }
  .wheel-btn { width:100%; padding:6px 8px; border-radius:6px; border:1px solid #ddd; background:white; cursor:pointer; font-size:16px; }
  .wheel-view { width:100%; height:72px; overflow:hidden; border-radius:8px; border:1px solid #e6e6e6; display:flex; align-items:center; justify-content:center; position:relative; background:#fafafa; }
  .wheel-list { position:absolute; left:0; right:0; display:flex; flex-direction:column; align-items:center; transition:transform .18s cubic-bezier(.2,.9,.2,1); }
  .wheel-item { width:100%; padding:6px 8px; text-align:center; font-weight:600; opacity:0.45; font-size:0.95em; }
  .wheel-item.center { opacity:1; font-size:1.15em; }

  /* Months row */
  .months { display:flex; flex-wrap:wrap; gap:6px; }
  .month-btn { padding:6px 8px; border-radius:6px; border:1px solid #ddd; background:white; cursor:pointer; font-size:0.95em; }
  .month-btn[aria-pressed="true"] { background:#eef3ff; border-color:#b7c6ff; font-weight:600; }

  /* Article list */
  .item { display:block; padding:8px; border-radius:6px; text-decoration:none; color:inherit; margin-bottom:6px; }
  .date { font-size:0.9em; color:#444; display:block; }
  .score-badge { display:inline-block; padding:3px 6px; border-radius:4px; font-weight:600; margin-right:8px; }

  /* Small screens */
  @media (max-width:600px) {
    body { flex-direction:column; height:auto; }
    nav { width:100%; max-height:250px; overflow:hidden; transition:max-height .26s ease, box-shadow .18s ease; border-right:none; border-bottom:1px solid #ddd; 
	position: relative;}  /* change max-height to change height on mobile */
    nav.expanded { max-height:80vh; overflow:auto; box-shadow:0 6px 16px rgba(0,0,0,0.06); }
    .nav-peek-handle { position:absolute; right:12px; top:12px; z-index:3; padding:6px 8px; font-size:13px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer; }
    nav::after { content:""; position:absolute; left:0; right:0; bottom:0; height:36px; pointer-events:none; background:linear-gradient(rgba(255,255,255,0), rgba(255,255,255,1)); }
  }

  /* Focus */
  .nav-peek-handle:focus, .month-btn:focus, a.item:focus, .wheel-btn:focus, .wheel-view:focus { outline:2px solid Highlight; outline-offset:2px; }
</style>
</head>
<body>

  <nav id="sidebar" aria-label="Articles">
    <div style="position:relative">
      <button class="nav-peek-handle" id="peekHandle" aria-expanded="false" title="Menu">Menu</button>
      <h2 style="margin:0 0 8px 0">Articles</h2>
    </div>

    <div class="controls">
      <!-- Year wheel selector -->
      <div class="year-wheel" aria-label="Year selector">
        <button id="yearUp" class="wheel-btn" aria-label="Previous year">^</button>
        <div id="wheelView" class="wheel-view" tabindex="0" role="spinbutton" aria-label="Year" aria-valuenow="">
          <div id="wheelList" class="wheel-list"></div>
        </div>
        <button id="yearDown" class="wheel-btn" aria-label="Next year">v</button>
      </div>

      <!-- Month buttons -->
      <div>
        <label style="font-size:0.85em;color:#333">Month</label>
        <div class="months" id="monthsRow" role="toolbar" aria-label="Months"></div>
      </div>
    </div>

    <div id="list" aria-live="polite"></div>
  </nav>

  <main id="content">
    <p>Select an article</p>
  </main>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
const monthsNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const listEl = document.getElementById('list');
const contentEl = document.getElementById('content');
const monthsRow = document.getElementById('monthsRow');
const peekHandle = document.getElementById('peekHandle');
const sidebar = document.getElementById('sidebar');

const wheelList = document.getElementById('wheelList');
const wheelView = document.getElementById('wheelView');
const yearUp = document.getElementById('yearUp');
const yearDown = document.getElementById('yearDown');

let indexData = [];
let grouped = {};
let years = [];
let selectedYear = null;
let selectedMonth = null;
const articleCache = new Map();

function parseDateParts(d) {
  if (!d) return null;
  const s = String(d);
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return { year:+s.slice(0,4), month:+s.slice(5,7), day:+s.slice(8,10) };
  if (/^\d{8}$/.test(s)) return { year:+s.slice(0,4), month:+s.slice(4,6), day:+s.slice(6,8) };
  return null;
}

function formatDate(d) {
  const p = parseDateParts(d);
  if (!p) return '';
  return `${p.year}-${String(p.month).padStart(2,'0')}-${String(p.day).padStart(2,'0')}`;
}

function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function createItemNode(item) {
  const a = document.createElement('a');
  a.href = '#'+item.filename;
  a.className = 'item';
  a.dataset.filename = item.filename;
  const hue = (item.score || 0) * 13;
  const badge = `<span class="score-badge" style="background:hsl(${hue},70%,75%)">${item.score||0}</span>`;
  a.innerHTML = badge + '<strong>' + escapeHtml(item.title) + '</strong><span class="date">' + formatDate(item.date) + '</span>';
  return a;
}

function renderMonthList(year, monthIndex) {
  listEl.innerHTML = '';
  if (!grouped[year] || !grouped[year][monthIndex]) {
    listEl.innerHTML = '<p>No articles for this month.</p>';
    return;
  }
  const frag = document.createDocumentFragment();
  grouped[year][monthIndex].forEach(it => frag.appendChild(createItemNode(it)));
  listEl.appendChild(frag);
}

function populateMonthsRow() {
  monthsRow.innerHTML = '';
  monthsNames.forEach((m,i) => {
    const b = document.createElement('button');
    b.className = 'month-btn';
    b.textContent = m;
    b.setAttribute('aria-pressed','false');
    b.addEventListener('click', () => selectMonth(i));
    monthsRow.appendChild(b);
  });
}

function updateMonthButtons() {
  monthsRow.querySelectorAll('.month-btn').forEach((b,i) =>
    b.setAttribute('aria-pressed', (i===selectedMonth).toString())
  );
}

function selectMonth(mi) {
  selectedMonth = mi;
  updateMonthButtons();
  if (selectedYear != null) renderMonthList(selectedYear, selectedMonth);
}

// ----- Year wheel logic -----
const VISIBLE_COUNT = 5;
let yearWindowStart = 0;

function renderWheel() {
  wheelList.innerHTML = '';
  if (!years.length) return;

  // clamp yearWindowStart so the window fits inside the years array
  //const maxStart = Math.max(0, years.length - VISIBLE_COUNT);
  //yearWindowStart = Math.max(0, Math.min(yearWindowStart, maxStart));
  const maxStart = Math.max(0, years.length - VISIBLE_COUNT);
 
  const frag = document.createDocumentFragment();
  for (let i=0;i<VISIBLE_COUNT;i++) {
    const idx = yearWindowStart + i;
    const d = document.createElement('div');
    d.className = 'wheel-item';
    d.textContent = (idx >= 0 && idx < years.length) ? String(years[idx]) : '';
    d.dataset.index = String(idx);
    frag.appendChild(d);
  }
  wheelList.appendChild(frag);

	const selectedIdx = (selectedYear != null) ? years.indexOf(selectedYear) : -1;
	wheelList.querySelectorAll('.wheel-item').forEach((el,i)=>{
	  const absIdx = yearWindowStart + i;
	  el.classList.toggle('center', absIdx === selectedIdx);
	});

  if (selectedYear!=null) wheelView.setAttribute('aria-valuenow', String(selectedYear));
}

function refreshWheelAroundIndex(index) {
  // center the window on index when possible
  const center = Math.floor(VISIBLE_COUNT/2);
  // center the window on the requested index; allow start to be negative or > maxStart so the selected
  // year appears in the middle and out-of-range slots render empty.
  let start = index - center;
  yearWindowStart = start;
  renderWheel();
}

function stepYear(delta) {
  if (!years.length) return;
  // find current index (default to 0 if missing)
  let idx = years.indexOf(selectedYear);
  if (idx === -1) idx = 0;
  // move index by delta (positive => toward later array indices)
  let newIdx = idx + delta;
  if (newIdx < 0) newIdx = 0;
  if (newIdx > years.length - 1) newIdx = years.length - 1;
  selectedYear = years[newIdx];

  // ensure selectedMonth is valid for the new year
  const monthsForYear = grouped[selectedYear] || {};
  const available = Object.keys(monthsForYear).map(Number).sort((a,b)=>a-b);
  if (!available.length) {
    selectedMonth = 0;
  } else if (!available.includes(selectedMonth)) {
    selectedMonth = available[0];
  }

  refreshWheelAroundIndex(newIdx);
  updateMonthButtons();
  renderMonthList(selectedYear, selectedMonth);
}

// wire controls: note '^' should move to earlier index (-1) and 'V' to +1
yearUp.addEventListener('click', ()=>stepYear(-1));
yearDown.addEventListener('click', ()=>stepYear(1));

// keyboard and wheel on the wheelView
wheelView.addEventListener('keydown', ev=>{
  if (ev.key==='ArrowUp') { ev.preventDefault(); stepYear(-1); }
  if (ev.key==='ArrowDown') { ev.preventDefault(); stepYear(1); }
});
wheelView.addEventListener('wheel', ev=>{
  ev.preventDefault();
  const d = Math.sign(ev.deltaY) || 0;
  // deltaY > 0 means wheel scrolled down, so move index +1
  stepYear(d);
});

// allow clicking an item in the wheel to jump there
wheelList.addEventListener('click', ev=>{
  const item = ev.target.closest('.wheel-item');
  if (!item) return;
  const idx = Number(item.dataset.index);
  if (!Number.isFinite(idx) || idx < 0 || idx >= years.length) return;
  selectedYear = years[idx];
  // adjust selected month
  const monthsForYear = grouped[selectedYear] || {};
  const available = Object.keys(monthsForYear).map(Number).sort((a,b)=>a-b);
  selectedMonth = available.length ? available[0] : 0;
  refreshWheelAroundIndex(idx);
  updateMonthButtons();
  renderMonthList(selectedYear, selectedMonth);
});

// Sidebar interactions
listEl.addEventListener('click', ev=>{
  const a = ev.target.closest('a.item'); if (!a) return;
  ev.preventDefault(); const f=a.dataset.filename;
  if (location.hash.slice(1)!==f) location.hash=f;
  loadArticle(f);
  if (matchMedia('(max-width:600px)').matches) {
  sidebar.classList.remove('expanded');
  peekHandle.setAttribute('aria-expanded','false');
  sidebar.scrollTop = 0; // reset menu scroll so "Menu" button is visible next time
}
});

peekHandle.addEventListener('click', ev=>{
  ev.stopPropagation();
  const isOpen = sidebar.classList.toggle('expanded');
  peekHandle.setAttribute('aria-expanded', String(isOpen));
});

async function loadArticle(filename) {
  if (!filename) return;
  contentEl.innerHTML = '<p>Loading...</p>';
  if (articleCache.has(filename)) { contentEl.innerHTML = articleCache.get(filename); return; }
  try {
    const r = await fetch('responses/'+filename);
    if (!r.ok) { contentEl.innerHTML = '<p>Cannot load file.</p>'; return; }
    const md = await r.text();
    const html = marked.parse(md);
    articleCache.set(filename, html);
    contentEl.innerHTML = html;
    window.scrollTo(0,0);
  } catch (err) {
    console.error(err);
    contentEl.innerHTML = '<p>Error loading.</p>';
  }
}

async function loadIndex() {
  try {
    const res = await fetch('index.json');
    if (!res.ok) throw new Error('index.json not found');
    indexData = await res.json();

    grouped = {};
    indexData.forEach(it=>{
      const p = parseDateParts(it.date); if (!p) return;
      const y=p.year, m=p.month-1;
      grouped[y] = grouped[y] || {};
      grouped[y][m] = grouped[y][m] || [];
      grouped[y][m].push(it);
    });
    Object.keys(grouped).forEach(y=>Object.keys(grouped[y]).forEach(m=>{
      grouped[y][m].sort((a,b)=>(b.date||'').localeCompare(a.date||''));
    }));

    years = Object.keys(grouped).map(Number).sort((a,b)=>b-a); // descending
    populateMonthsRow();

    // choose initial selection: prefer hash, otherwise most recent year
    const initialHash = location.hash ? location.hash.slice(1) : null;
    let initialFilename = initialHash || null;
	if (!initialFilename && indexData && indexData.length) {
	  // choose the article whose date is closest to exactly 10 years ago from today
	  const now = new Date();
	  const target = new Date(now.getFullYear() - 10, now.getMonth(), now.getDate());
	  let closest = null;
	  let bestDiff = Infinity;
	  indexData.forEach(it => {
		const p = parseDateParts(it.date);
		if (!p) return;
		const d = new Date(p.year, p.month - 1, p.day);
		const diff = Math.abs(d - target);
		if (diff < bestDiff) {
		  bestDiff = diff;
		  closest = it;
		}
	  });
	  initialFilename = closest ? closest.filename : (indexData[0] && indexData[0].filename);
	}


    if (initialFilename) {
      const found = indexData.find(it=>it.filename===initialFilename);
      if (found) {
        const p = parseDateParts(found.date);
        if (p) { selectedYear = p.year; selectedMonth = p.month - 1; }
      }
    }

    // fallback to most recent year/month
    if (selectedYear === null) selectedYear = years.length ? years[0] : null;
    if (selectedMonth === null) {
      const monthsForYear = grouped[selectedYear] || {};
      const available = Object.keys(monthsForYear).map(k=>+k).sort((a,b)=>a-b);
      selectedMonth = available.length ? available[0] : 0;
    }

    // ensure selectedYear exists in years array
    if (!years.includes(selectedYear)) selectedYear = years[0] ?? null;
    const idx = years.indexOf(selectedYear);
    refreshWheelAroundIndex(Math.max(0, idx));
    updateMonthButtons();
    if (selectedYear != null) renderMonthList(selectedYear, selectedMonth);

    if (initialFilename) loadArticle(initialFilename);

    window.addEventListener('hashchange', () => {
      const f = location.hash.slice(1);
      if (f) loadArticle(f);
    });

  } catch (err) {
    console.error(err);
    contentEl.innerHTML = '<p>Cannot load index.</p>';
  }
}

loadIndex();
</script>
</body>
</html>
